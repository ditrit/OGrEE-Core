package repository

import (
	"context"
	"fmt"
	"strings"
	"time"

	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"

	u "p3/utils"
)

func GetObject(req bson.M, ent string, filters u.RequestFilters) (map[string]interface{}, *u.Error) {
	ctx, cancel := u.Connect()
	defer cancel()
	t := map[string]interface{}{}

	opts := GetFieldsToShowOneFilter(filters.FieldsToShow)

	err := GetDateFilters(req, filters.StartDate, filters.EndDate)
	if err != nil {
		return nil, &u.Error{Type: u.ErrBadFormat, Message: err.Error()}
	}

	if opts != nil {
		err = GetDB().Collection(ent).FindOne(ctx, req, opts).Decode(&t)
	} else {
		err = GetDB().Collection(ent).FindOne(ctx, req).Decode(&t)
	}
	if err != nil {
		if err == mongo.ErrNoDocuments {
			return nil, &u.Error{Type: u.ErrNotFound,
				Message: "Nothing matches this request"}
		}
		return nil, &u.Error{Type: u.ErrBadFormat, Message: err.Error()}
	}

	return t, nil
}

func GetObjectSiteParent(objId string) (map[string]any, *u.Error) {
	data := map[string]any{}

	// Get all collections names
	ctx, cancel := u.Connect()
	db := GetDB()
	collNames, err := db.ListCollectionNames(ctx, bson.D{})
	if err != nil {
		fmt.Println(err.Error())
		return nil, &u.Error{Type: u.ErrDBError, Message: err.Error()}
	}

	// Find object
	for _, collName := range collNames {
		if err := db.Collection(collName).FindOne(ctx, bson.M{"id": objId}).Decode(&data); err != nil {
			continue
		}
		// Found object with given id
		if data["category"].(string) == "site" {
			// it's a site
			break
		} else {
			// Find its parent site
			nameSlice := strings.Split(data["id"].(string), u.HN_DELIMETER)
			siteName := nameSlice[0] // CONSIDER SITE AS 0
			if err := db.Collection("site").FindOne(ctx, bson.M{"id": siteName}).Decode(&data); err != nil {
				return nil, &u.Error{Type: u.ErrNotFound,
					Message: "Could not find parent site for given object"}
			}
		}
	}
	defer cancel()
	return data, nil
}

func GetByAutogeneratedID[T any](collection, id string) (*T, *u.Error) {
	ctx, cancel := u.Connect()
	defer cancel()
	objectID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, &u.Error{Type: u.ErrBadFormat, Message: err.Error()}
	}

	var entity T

	err = GetDB().Collection(collection).FindOne(
		ctx,
		bson.M{"_id": objectID},
	).Decode(&entity)
	if err != nil {
		if err == mongo.ErrNoDocuments {
			return nil, &u.Error{Type: u.ErrNotFound,
				Message: "Nothing matches this request"}
		}
		return nil, &u.Error{Type: u.ErrDBError, Message: err.Error()}
	}

	return &entity, nil
}

func CreateObject(ctx context.Context, collection string, data any) (primitive.ObjectID, *u.Error) {
	if dataMap, isMap := data.(map[string]any); isMap {
		// Set timestamp
		dataMap["createdDate"] = primitive.NewDateTimeFromTime(time.Now())
		dataMap["lastUpdated"] = dataMap["createdDate"]
		data = dataMap
	}

	result, err := GetDB().Collection(collection).InsertOne(ctx, data)
	if err != nil {
		if mongo.IsDuplicateKeyError(err) {
			return primitive.NilObjectID, &u.Error{Type: u.ErrDuplicate,
				Message: "Error while creating " + collection + ": Duplicates not allowed"}
		}

		return primitive.NilObjectID, &u.Error{Type: u.ErrDBError,
			Message: "Internal error while creating " + collection + ": " + err.Error()}
	}

	return result.InsertedID.(primitive.ObjectID), nil
}

func DeleteObject(ctx context.Context, entity string, filter bson.M) *u.Error {
	result, err := GetDB().Collection(entity).DeleteOne(ctx, filter)
	if err != nil {
		return &u.Error{Type: u.ErrDBError, Message: err.Error()}
	}

	if result.DeletedCount == 0 {
		return &u.Error{Type: u.ErrNotFound, Message: "Error deleting object: not found"}
	}

	return nil
}

// PropagateParentIdChange: search for given parent children and
// update their hierarchyName with new parent name
func PropagateParentIdChange(ctx context.Context, oldParentId, newId string, entityInt int) error {
	// Find all objects containing parent name
	req := bson.M{"id": primitive.Regex{Pattern: oldParentId + u.HN_DELIMETER, Options: ""}}
	// For each object found, replace old name by new
	update := bson.D{{
		Key: "$set", Value: bson.M{
			"id": bson.M{
				"$replaceOne": bson.M{
					"input":       "$id",
					"find":        oldParentId,
					"replacement": newId}}}}}
	if entityInt == u.DOMAIN {
		_, err := GetDB().Collection(u.EntityToString(u.DOMAIN)).UpdateMany(ctx,
			req, mongo.Pipeline{update})
		if err != nil {
			println(err.Error())
			return err
		}
	} else if entityInt == u.DEVICE {
		_, err := GetDB().Collection(u.EntityToString(u.DEVICE)).UpdateMany(ctx,
			req, mongo.Pipeline{update})
		if err != nil {
			println(err.Error())
			return err
		}
	} else {
		for i := entityInt + 1; i <= u.GROUP; i++ {
			_, err := GetDB().Collection(u.EntityToString(i)).UpdateMany(ctx,
				req, mongo.Pipeline{update})
			if err != nil {
				println(err.Error())
				return err
			}
		}
	}
	return nil
}

// PropagateDomainChange: search for all objects with reference to the modified domain
func PropagateDomainChange(ctx context.Context, oldDomainId, newDomainId string) error {
	// Find all objects containing this domain
	req := bson.M{"domain": primitive.Regex{Pattern: "^" + oldDomainId + "(\\" + u.HN_DELIMETER + "|$)", Options: ""}}
	// For each object found, replace old domain by new
	update := bson.D{{
		Key: "$set", Value: bson.M{
			"domain": bson.M{
				"$replaceOne": bson.M{
					"input":       "$domain",
					"find":        oldDomainId,
					"replacement": newDomainId}}}}}
	for i := u.STRAYOBJ; i <= u.GROUP; i++ {
		_, err := GetDB().Collection(u.EntityToString(i)).UpdateMany(ctx,
			req, mongo.Pipeline{update})
		if err != nil {
			return err
		}
	}
	return nil
}

// PropagateDomainChangeToChildren: update domain of all children to the new domain of its parent
func PropagateDomainChangeToChildren(ctx context.Context, parentId, newDomainId string) error {
	// Find all objects containing parent name
	req := bson.M{"id": primitive.Regex{Pattern: parentId + u.HN_DELIMETER, Options: ""}}
	// For each object found, replace old domain by new
	update := bson.D{{
		Key: "$set", Value: bson.M{
			"domain": newDomainId}}}
	for i := u.BLDG; i <= u.GROUP; i++ {
		_, err := GetDB().Collection(u.EntityToString(i)).UpdateMany(ctx,
			req, mongo.Pipeline{update})
		if err != nil {
			return err
		}
	}
	return nil
}

// CheckParentDomainChange: check if children have same or child of parent's new domain
func CheckParentDomainChange(parentEntity int, parentId, parenDomain string) *u.Error {
	andReq := bson.A{}
	andReq = append(andReq, bson.M{"id": primitive.Regex{Pattern: parentId + u.HN_DELIMETER, Options: ""}})
	andReq = append(andReq, bson.M{"domain": bson.M{"$not": primitive.Regex{Pattern: "^" + parenDomain + "(\\" + u.HN_DELIMETER + "|$)", Options: ""}}})
	req := bson.M{"$and": andReq}
	startEntity := parentEntity + 1
	if parentEntity == u.DEVICE {
		startEntity = u.DEVICE
	}
	for entity := startEntity; entity <= u.GROUP; entity++ {
		countEntity, err := CountObjects(entity, req)
		if err != nil {
			return err
		}
		if countEntity > 0 {
			return &u.Error{Type: u.ErrInvalidValue, Message: "New domain is not compatible with children's domain"}
		}
	}

	return nil
}

func CountObjects(entity int, req bson.M) (int, *u.Error) {
	ctx, cancel := u.Connect()
	defer cancel()
	count, err := GetDB().Collection(u.EntityToString(entity)).CountDocuments(ctx, req)
	if err != nil {
		return 0, &u.Error{Type: u.ErrDBError, Message: err.Error()}
	}

	return int(count), nil
}

func CountObjectsManyEntities(entities []int, req bson.M) (int, *u.Error) {
	count := 0
	for _, entity := range entities {
		countEntity, err := CountObjects(entity, req)
		if err != nil {
			return 0, err
		}

		count = count + int(countEntity)
	}

	return count, nil
}
