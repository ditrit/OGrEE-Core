package repository

import (
	"context"
	"time"

	"go.mongodb.org/mongo-driver/bson"
	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo"
	"go.mongodb.org/mongo-driver/mongo/options"

	u "p3/utils"
)

func GetObject(ctx context.Context, req bson.M, ent string, filters u.RequestFilters) (map[string]interface{}, *u.Error) {
	t := map[string]interface{}{}

	var opts *options.FindOneOptions
	if len(filters.FieldsToShow) > 0 {
		compoundIndex := bson.D{bson.E{Key: "domain", Value: 1}, bson.E{Key: "id", Value: 1}}
		for _, field := range filters.FieldsToShow {
			if field != "domain" && field != "id" {
				compoundIndex = append(compoundIndex, bson.E{Key: field, Value: 1})
			}
		}
		opts = options.FindOne().SetProjection(compoundIndex)
	}

	err := GetDateFilters(req, filters.StartDate, filters.EndDate)
	if err != nil {
		return nil, &u.Error{Type: u.ErrBadFormat, Message: err.Error()}
	}

	if opts != nil {
		err = GetDB().Collection(ent).FindOne(ctx, req, opts).Decode(&t)
	} else {
		err = GetDB().Collection(ent).FindOne(ctx, req).Decode(&t)
	}
	if err != nil {
		if err == mongo.ErrNoDocuments {
			return nil, &u.Error{Type: u.ErrNotFound,
				Message: "Nothing matches this request"}
		}
		return nil, &u.Error{Type: u.ErrBadFormat, Message: err.Error()}
	}

	return t, nil
}

func GetByAutogeneratedID[T any](ctx context.Context, collection, id string) (*T, *u.Error) {
	objectID, err := primitive.ObjectIDFromHex(id)
	if err != nil {
		return nil, &u.Error{Type: u.ErrBadFormat, Message: err.Error()}
	}

	var entity T

	err = GetDB().Collection(collection).FindOne(
		ctx,
		bson.M{"_id": objectID},
	).Decode(&entity)
	if err != nil {
		if err == mongo.ErrNoDocuments {
			return nil, &u.Error{Type: u.ErrNotFound,
				Message: "Nothing matches this request"}
		}
		return nil, &u.Error{Type: u.ErrDBError, Message: err.Error()}
	}

	return &entity, nil
}

func CreateObject(ctx context.Context, collection string, data any) (primitive.ObjectID, *u.Error) {
	if dataMap, isMap := data.(map[string]any); isMap {
		// Set timestamp
		dataMap["createdDate"] = primitive.NewDateTimeFromTime(time.Now())
		dataMap["lastUpdated"] = dataMap["createdDate"]
		data = dataMap
	}

	result, err := GetDB().Collection(collection).InsertOne(ctx, data)
	if err != nil {
		if mongo.IsDuplicateKeyError(err) {
			return primitive.NilObjectID, &u.Error{Type: u.ErrDuplicate,
				Message: "Error while creating " + collection + ": Duplicates not allowed"}
		}

		return primitive.NilObjectID, &u.Error{Type: u.ErrDBError,
			Message: "Internal error while creating " + collection + ": " + err.Error()}
	}

	return result.InsertedID.(primitive.ObjectID), nil
}

func DeleteObject(ctx context.Context, entity string, filter bson.M) *u.Error {
	result, err := GetDB().Collection(entity).DeleteOne(ctx, filter)
	if err != nil {
		return &u.Error{Type: u.ErrDBError, Message: err.Error()}
	}

	if result.DeletedCount == 0 {
		return &u.Error{Type: u.ErrNotFound, Message: "Error deleting object: not found"}
	}

	return nil
}

// PropagateParentIdChange: search for given parent children and
// update their hierarchyName with new parent name
func PropagateParentIdChange(ctx context.Context, oldParentId, newId string, entityInt int) error {
	// Find all objects containing parent name
	req := bson.M{"id": primitive.Regex{Pattern: oldParentId + u.HN_DELIMETER, Options: ""}}
	// For each object found, replace old name by new
	update := bson.D{{
		Key: "$set", Value: bson.M{
			"id": bson.M{
				"$replaceOne": bson.M{
					"input":       "$id",
					"find":        oldParentId,
					"replacement": newId}}}}}
	if entityInt == u.DOMAIN {
		_, err := GetDB().Collection(u.EntityToString(u.DOMAIN)).UpdateMany(ctx,
			req, mongo.Pipeline{update})
		if err != nil {
			println(err.Error())
			return err
		}
	} else if entityInt == u.DEVICE {
		_, err := GetDB().Collection(u.EntityToString(u.DEVICE)).UpdateMany(ctx,
			req, mongo.Pipeline{update})
		if err != nil {
			println(err.Error())
			return err
		}
	} else {
		for i := entityInt + 1; i <= u.GROUP; i++ {
			_, err := GetDB().Collection(u.EntityToString(i)).UpdateMany(ctx,
				req, mongo.Pipeline{update})
			if err != nil {
				println(err.Error())
				return err
			}
		}
	}
	return nil
}

// PropagateDomainChange: search for all objects with reference to the modified domain
func PropagateDomainChange(ctx context.Context, oldDomainId, newDomainId string) error {
	// Find all objects containing this domain
	req := bson.M{"domain": primitive.Regex{Pattern: "^" + oldDomainId + "(\\" + u.HN_DELIMETER + "|$)", Options: ""}}
	// For each object found, replace old domain by new
	update := bson.D{{
		Key: "$set", Value: bson.M{
			"domain": bson.M{
				"$replaceOne": bson.M{
					"input":       "$domain",
					"find":        oldDomainId,
					"replacement": newDomainId}}}}}
	for i := u.STRAYOBJ; i <= u.GROUP; i++ {
		_, err := GetDB().Collection(u.EntityToString(i)).UpdateMany(ctx,
			req, mongo.Pipeline{update})
		if err != nil {
			return err
		}
	}
	return nil
}
